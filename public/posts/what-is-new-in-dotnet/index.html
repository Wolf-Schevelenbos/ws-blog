<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What Is New in Dotnet | Wolf's Blog</title>
<meta name=keywords content="tech,passive event"><meta name=description content="This is a post about a talk about .NET by Starfisk"><meta name=author content="Wolf Schevelenbos"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.d72444526d7ecbdb0015438a7fa89054a658bf759d0542e2e5df81ce94b493ee.css integrity="sha256-1yREUm1+y9sAFUOKf6iQVKZYv3WdBULi5d+BzpS0k+4=" rel="preload stylesheet" as=style><link rel=icon href=https://wolfschevelenbos.netlify.app/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wolfschevelenbos.netlify.app/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wolfschevelenbos.netlify.app/favicon-32x32.png><link rel=apple-touch-icon href=https://wolfschevelenbos.netlify.app/apple-touch-icon.png><link rel=mask-icon href=https://wolfschevelenbos.netlify.app/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wolfschevelenbos.netlify.app/posts/what-is-new-in-dotnet/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wolfschevelenbos.netlify.app/posts/what-is-new-in-dotnet/"><meta property="og:site_name" content="Wolf's Blog"><meta property="og:title" content="What Is New in Dotnet"><meta property="og:description" content="This is a post about a talk about .NET by Starfisk"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-22T18:45:04+01:00"><meta property="article:modified_time" content="2024-10-22T18:45:04+01:00"><meta property="article:tag" content="Tech"><meta property="article:tag" content="Passive Event"><meta property="og:image" content="https://wolfschevelenbos.netlify.app/posts/what-is-new-in-dotnet/images/starfisk-entrance.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wolfschevelenbos.netlify.app/posts/what-is-new-in-dotnet/images/starfisk-entrance.jpg"><meta name=twitter:title content="What Is New in Dotnet"><meta name=twitter:description content="This is a post about a talk about .NET by Starfisk"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wolfschevelenbos.netlify.app/posts/"},{"@type":"ListItem","position":2,"name":"What Is New in Dotnet","item":"https://wolfschevelenbos.netlify.app/posts/what-is-new-in-dotnet/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What Is New in Dotnet","name":"What Is New in Dotnet","description":"This is a post about a talk about .NET by Starfisk","keywords":["tech","passive event"],"articleBody":"Starfisk is a small company of 9 people in Bruges. They’re consultants. Colin Bundervoet, one of their developers, held an event called “What’s new in .Net” to inform students, like me, of the new developments in dotnet.\n.Net .NET is a free, open-source developer platform created by Microsoft for building a wide range of applications. It supports multiple programming languages and enables the development of web, desktop, mobile, cloud, gaming, Internet of Things (IoT), and artificial intelligence (AI) applications.\nThis was a general introduction to .NET. It was common knowledge for most, if not all, of us students that went to visit Starfisk’s event. Colin Bundervoet then went on to tell us of the history on .NET.\nHistory The .NET Framework. It is an older, Windows-only platform ideal for legacy applications and technologies like WPF and Windows Forms, but it’s no longer actively evolving.\nIn contrast, .NET Core is a modern, cross-platform, high-performance framework designed for building cloud-native and scalable applications, now unified under .NET 5 and beyond. While the .NET Framework remains stable for existing projects, .NET Core (or .NET 5+) is the future of .NET development.\nVersions Even-numbered .NET versions (e.g., .NET 6, .NET 8) are long-term support (LTS) releases, designed for stability and supported for three years, making them ideal for production environments.\nOdd-numbered versions (e.g., .NET 5, .NET 7) are standard-term releases with shorter support of one year, focusing on delivering new features and improvements quickly.\nHe then went on to go over some notable changes through the ages per version. I’ll briefly list those he covered below, though be warned as it can get fairly technical. Feel free to skip to the Predictions section of this text.\nEarly versions (up to C# 9 \u0026 .NET 5) Records in C# are reference types designed for immutable data models, introduced in C# 9. They provide concise syntax for defining objects with value-based equality, making them ideal for scenarios like data transfer objects. Unlike regular classes, records use with expressions for shallow copies and automatically generate useful methods like ToString, GetHashCode, and equality checks.\nSpan is a stack-allocated, high-performance type for managing contiguous memory, ideal for scenarios requiring slicing or processing memory without allocations. It is restricted to synchronous operations and cannot be stored in fields or used across asynchronous calls.\nMemory, in contrast, is a heap-allocated, more flexible type that supports asynchronous use cases and allows safe persistence in fields. While less performant than Span, it provides compatibility with broader scenarios like async methods and background processing.\nC# 10 \u0026 .NET 6 Global usings allow you to declare commonly used namespaces in a single file (e.g., global using System;), making them accessible throughout the entire project. This reduces boilerplate code by avoiding repeated using statements in every file.\nglobal using System; global using System.Collections.Generic; Top-Level Statements simplify the entry point of an application by allowing you to write code directly without wrapping it in a Main method or class. Perfect for small programs and reduces boilerplate.\nConsole.WriteLine(\"Hello, World!\"); // No need for \"static void Main\" or a class wrapper. Target-Typed new simplifies object initialization by inferring the type from the context, reducing redundancy when declaring variables.\nList\u003cint\u003e numbers = new(); // Compiler infers List as the type. Constant interpolated strings can now be marked as const if their contents consist only of other constant values.\nconst string name = \"World\";\rconst string greeting = $\"Hello, {name}!\"; Tuple-based declarations and assignments, useful for swapping values or initializing multiple variables concisely, were introduced.\nint a = 1, b = 2;\r(a, b) = (b, a); // Swaps the values of a and b.\rConsole.WriteLine($\"a: {a}, b: {b}\"); // Output: a: 2, b: 1 Pattern matching extended support was introduced for switch expressions, relational patterns (\u003c, \u003e=, etc.), and logical patterns (and, or, not) for more expressive and readable conditions.\nint number = 42; string result = number switch { \u003c 0 =\u003e \"Negative\", \u003e= 0 and \u003c= 10 =\u003e \"Small\", \u003e 10 =\u003e \"Large\" }; DateOnly and TimeOnly were introduced as lightweight types for working specifically with dates or times, simplifying scenarios where DateTime was overkill.\nDateOnly date = DateOnly.FromDateTime(DateTime.Now); // Just the date. TimeOnly time = TimeOnly.FromDateTime(DateTime.Now); // Just the time. Console.WriteLine($\"Date: {date}, Time: {time}\"); C# 11 \u0026 .NET 7 The required keyword ensures certain properties are initialized during object creation, with checks enforced at compile time. This complements nullable reference types by preventing unintentionally uninitialized values.\npublic class Person { public required string Name { get; init; } // Must be set when creating the object. } var person = new Person { Name = \"Alice\" }; // Valid. var invalidPerson = new Person(); // Compile-time error: Name is required. Generated Regex through the RegexGenerator attribute generates highly efficient, precompiled regular expressions at compile time. This avoids runtime overhead and ensures better performance.\nusing System.Text.RegularExpressions; [GeneratedRegex(\"^[a-zA-Z0-9]*$\")] private static partial Regex AlphanumericRegex(); bool isValid = AlphanumericRegex().IsMatch(\"Sample123\"); // Uses precompiled regex. String Improvements introduced multiline triple quotes and multiline JSON, which allows strings to span multiple lines easily, preserving indentation and formatting.\nstring multiline = \"\"\" This is a multi-line string with \"quotes\" and special characters! \"\"\"; string json = \"\"\" { \"name\": \"Alice\", \"age\": 30 } \"\"\"; Enhanced generic support makes it easier to create APIs or response types with consistent, type-safe handling of different data structures.\npublic class ApiResponse\u003cT\u003e { public T Data { get; set; } public int StatusCode { get; set; } } var response = new ApiResponse\u003cstring\u003e { Data = \"Success\", StatusCode = 200 }; File-scoped files allow you to declare types that are only accessible within the file they are defined in, improving encapsulation and reducing unintentional exposure.\nfile class InternalHelper { public static void DoSomething() =\u003e Console.WriteLine(\"This is file-scoped.\"); } C# 12 \u0026 .NET 8 Primary Constructors made it so classes and structs could now declare constructor parameters directly within the type declaration, simplifying initialization and reducing boilerplate.\npublic class Person(string name, int age) { public string Name { get; } = name; public int Age { get; } = age; } Collection Expressions provided a unified syntax for initializing collections, allowing concise creation of arrays, lists, and spans, with support for spread elements to include existing collections.\nint[] numbers = [1, 2, 3]; var moreNumbers = [..numbers, 4, 5]; Alias Any Type as the using directive now supported it, including tuples and pointer types, enhancing code readability and disambiguation.\nusing Point = (int X, int Y);\rPoint p = (10, 20); Layered Dependency Injection was improved. .NET 8 enhanced injection by allowing registration of multiple exception handlers that can be executed in a specified order, facilitating more granular error handling.\nbuilder.Services.AddExceptionHandler\u003cTimeoutExceptionHandler\u003e(); builder.Services.AddExceptionHandler\u003cGlobalExceptionHandler\u003e(); Enhanced Exception Handling improved with the introduction of the IExceptionHandler interface, which enabled structured global exception handling without the need for custom middleware, allowing for more modular and maintainable error management.\npublic class GlobalExceptionHandler : IExceptionHandler { public async ValueTask\u003cbool\u003e TryHandleAsync(HttpContext httpContext, Exception exception, CancellationToken cancellationToken) { // Handle exception return true; } } C# 13 \u0026 .NET 9 At the time of the event, this version wasn’t released yet. However, we did know what was coming and could talk about it.\nThe params keyword has been enhanced to support various collection types beyond arrays, such as Span, ReadOnlySpan, and types implementing IEnumerable with an Add method. This enhancement allows for more flexible and efficient method parameter definitions.\npublic void AddNumbers(params Span\u003cint\u003e numbers) { foreach (var number in numbers) { Console.WriteLine(number); } } AddNumbers(1, 2, 3); // Now valid with Span Ordered dictionaries were added. .NET 9 introduces OrderedDictionary, a generic collection that maintains the order of elements as they are added, combining the features of a list and a dictionary.\nvar orderedDict = new OrderedDictionary\u003cstring, int\u003e { [\"apple\"] = 1, [\"banana\"] = 2, [\"cherry\"] = 3 }; foreach (var item in orderedDict) { Console.WriteLine($\"{item.Key}: {item.Value}\"); } The read-only set is a new collection type ReadOnlySet that provides a read-only wrapper around a set, allowing for the exposure of set data without permitting modifications.\nvar modifiableSet = new HashSet\u003cint\u003e { 1, 2, 3 }; var readOnlySet = new ReadOnlySet\u003cint\u003e(modifiableSet); Console.WriteLine(readOnlySet.Contains(2)); // True // readOnlySet.Add(4); // Compile-time error LINQ Enhancements were made. C# 13 introduces improvements to Language Integrated Query (LINQ), including support for indexing and new aggregation methods, enhancing the expressiveness and performance of LINQ queries.\nvar numbers = new[] { 1, 2, 3, 4, 5 }; var thirdElement = numbers.ElementAt(^3); // Index from end, retrieves 3 var sum = numbers.AggregateBy((total, next) =\u003e total + next); // Hypothetical new method The partial keyword has been extended to properties and indexers, allowing their declarations to be split across multiple partial class definitions.\n// In one part of the partial class public partial class SampleClass { public partial string Name { get; set; } } // In another part of the partial class public partial class SampleClass { public partial string Name { get; set; } = \"Default\"; } Predictions According to Colin Bundervoet, the future of .NET lies in leveraging extensions and roles to drive flexibility and maintainability in application development.\nHe predicts that extensions will continue to evolve as a way to add functionality to existing types without altering their original design, allowing for more modular and reusable code.\nBundervoet also sees roles as a game-changer, enabling type aliases with constraints and context-specific behaviors that enforce compile-time safety while improving code readability.\nHe believes these features will align .NET with modern design paradigms like domain-driven design, making it easier to build adaptable, scalable applications. In Bundervoet’s view, this focus on extensions and roles cements .NET’s position as a versatile and forward-thinking platform.\nFinal remarks In the end, we ended up networking a bit amongst ourselves and with the people at Starfisk. We discussed Bruges, our studies and the Colin Bundervoet’s talk extensively. There were free drinks and snacks as well, which kept us there for about half an hour after.\n","wordCount":"1652","inLanguage":"en","image":"https://wolfschevelenbos.netlify.app/posts/what-is-new-in-dotnet/images/starfisk-entrance.jpg","datePublished":"2024-10-22T18:45:04+01:00","dateModified":"2024-10-22T18:45:04+01:00","author":{"@type":"Person","name":"Wolf Schevelenbos"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wolfschevelenbos.netlify.app/posts/what-is-new-in-dotnet/"},"publisher":{"@type":"Organization","name":"Wolf's Blog","logo":{"@type":"ImageObject","url":"https://wolfschevelenbos.netlify.app/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wolfschevelenbos.netlify.app/ accesskey=h title="Wolf's blog (Alt + H)"><img src=https://wolfschevelenbos.netlify.app/ws-blog/assets/icon/apple-touch-icon.png alt aria-label=logo height=35>Wolf's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wolfschevelenbos.netlify.app/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://wolfschevelenbos.netlify.app/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://wolfschevelenbos.netlify.app/about/ title=About><span>About</span></a></li><li><a href=https://wolfschevelenbos.netlify.app/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wolfschevelenbos.netlify.app/>Home</a>&nbsp;»&nbsp;<a href=https://wolfschevelenbos.netlify.app/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">What Is New in Dotnet</h1><div class=post-description>This is a post about a talk about .NET by Starfisk</div><div class=post-meta><span title='2024-10-22 18:45:04 +0100 +0100'>October 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1652 words&nbsp;·&nbsp;Wolf Schevelenbos&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/what-is-new-in-dotnet.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#net>.Net</a><ul><li><a href=#history>History</a></li><li><a href=#versions>Versions</a></li></ul></li><li><a href=#predictions>Predictions</a></li><li><a href=#final-remarks>Final remarks</a></li></ul></nav></div></details></div><div class=post-content><p>Starfisk is a small company of 9 people in Bruges. They&rsquo;re consultants. Colin Bundervoet, one of their developers, held an event called &ldquo;What&rsquo;s new in .Net&rdquo; to inform students, like me, of the new developments in dotnet.</p><p><img alt="picture of Colin Bundervoet" loading=lazy src=/images/starfisk-speaker.jpg#center></p><h2 id=net>.Net<a hidden class=anchor aria-hidden=true href=#net>#</a></h2><blockquote><p>.NET is a free, open-source developer platform created by Microsoft for building a wide range of applications. It supports multiple programming languages and enables the development of web, desktop, mobile, cloud, gaming, Internet of Things (IoT), and artificial intelligence (AI) applications.</p></blockquote><p>This was a general introduction to .NET. It was common knowledge for most, if not all, of us students that went to visit Starfisk&rsquo;s event. Colin Bundervoet then went on to tell us of the history on .NET.</p><h3 id=history>History<a hidden class=anchor aria-hidden=true href=#history>#</a></h3><p>The .NET Framework. It is an older, Windows-only platform ideal for legacy applications and technologies like WPF and Windows Forms, but it&rsquo;s no longer actively evolving.</p><p>In contrast, .NET Core is a modern, cross-platform, high-performance framework designed for building cloud-native and scalable applications, now unified under .NET 5 and beyond. While the .NET Framework remains stable for existing projects, .NET Core (or .NET 5+) is the future of .NET development.</p><h3 id=versions>Versions<a hidden class=anchor aria-hidden=true href=#versions>#</a></h3><p>Even-numbered .NET versions (e.g., .NET 6, .NET 8) are long-term support (LTS) releases, designed for stability and supported for three years, making them ideal for production environments.</p><p>Odd-numbered versions (e.g., .NET 5, .NET 7) are standard-term releases with shorter support of one year, focusing on delivering new features and improvements quickly.</p><p><img alt=".NET release schedule" loading=lazy src=/images/dotnet-release-schedule.svg></p><p>He then went on to go over some notable changes through the ages per version. I&rsquo;ll briefly list those he covered below, though be warned as it can get fairly technical. Feel free to skip to the <em>Predictions</em> section of this text.</p><h4 id=early-versions-up-to-c-9--net-5>Early versions (up to C# 9 & .NET 5)<a hidden class=anchor aria-hidden=true href=#early-versions-up-to-c-9--net-5>#</a></h4><p><strong>Records</strong> in C# are reference types designed for immutable data models, introduced in C# 9. They provide concise syntax for defining objects with value-based equality, making them ideal for scenarios like data transfer objects. Unlike regular classes, records use with expressions for shallow copies and automatically generate useful methods like <code>ToString</code>, <code>GetHashCode</code>, and equality checks.</p><p><code>Span&lt;T></code> is a stack-allocated, high-performance type for managing contiguous memory, ideal for scenarios requiring slicing or processing memory without allocations. It is restricted to synchronous operations and cannot be stored in fields or used across asynchronous calls.</p><p><code>Memory&lt;T></code>, in contrast, is a heap-allocated, more flexible type that supports asynchronous use cases and allows safe persistence in fields. While less performant than <code>Span&lt;T></code>, it provides compatibility with broader scenarios like async methods and background processing.</p><h4 id=c-10--net-6>C# 10 & .NET 6<a hidden class=anchor aria-hidden=true href=#c-10--net-6>#</a></h4><p><strong>Global usings</strong> allow you to declare commonly used namespaces in a single file (e.g., global using System;), making them accessible throughout the entire project. This reduces boilerplate code by avoiding repeated using statements in every file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>global</span> <span class=k>using</span> <span class=nn>System</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>global</span> <span class=k>using</span> <span class=nn>System.Collections.Generic</span><span class=p>;</span>
</span></span></code></pre></div><p><strong>Top-Level Statements</strong> simplify the entry point of an application by allowing you to write code directly without wrapping it in a Main method or class. Perfect for small programs and reduces boilerplate.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Hello, World!&#34;</span><span class=p>);</span> <span class=c1>// No need for &#34;static void Main&#34; or a class wrapper.</span>
</span></span></code></pre></div><p><strong>Target-Typed new</strong> simplifies object initialization by inferring the type from the context, reducing redundancy when declaring variables.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>numbers</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span> <span class=c1>// Compiler infers List&lt;int&gt; as the type.</span>
</span></span></code></pre></div><p><strong>Constant interpolated strings</strong> can now be marked as const if their contents consist only of other constant values.</p><pre tabindex=0><code>const string name = &#34;World&#34;;
const string greeting = $&#34;Hello, {name}!&#34;;
</code></pre><p><strong>Tuple-based declarations and assignments</strong>, useful for swapping values or initializing multiple variables concisely, were introduced.</p><pre tabindex=0><code>int a = 1, b = 2;
(a, b) = (b, a); // Swaps the values of a and b.
Console.WriteLine($&#34;a: {a}, b: {b}&#34;); // Output: a: 2, b: 1
</code></pre><p><strong>Pattern matching</strong> extended support was introduced for switch expressions, relational patterns (&lt;, >=, etc.), and logical patterns (and, or, not) for more expressive and readable conditions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span> <span class=n>number</span> <span class=p>=</span> <span class=m>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>string</span> <span class=n>result</span> <span class=p>=</span> <span class=n>number</span> <span class=k>switch</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span> <span class=m>0</span> <span class=p>=&gt;</span> <span class=s>&#34;Negative&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;=</span> <span class=m>0</span> <span class=n>and</span> <span class=p>&lt;=</span> <span class=m>10</span> <span class=p>=&gt;</span> <span class=s>&#34;Small&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>&gt;</span> <span class=m>10</span> <span class=p>=&gt;</span> <span class=s>&#34;Large&#34;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><strong>DateOnly and TimeOnly</strong> were introduced as lightweight types for working specifically with dates or times, simplifying scenarios where DateTime was overkill.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>DateOnly</span> <span class=n>date</span> <span class=p>=</span> <span class=n>DateOnly</span><span class=p>.</span><span class=n>FromDateTime</span><span class=p>(</span><span class=n>DateTime</span><span class=p>.</span><span class=n>Now</span><span class=p>);</span> <span class=c1>// Just the date.</span>
</span></span><span class=line><span class=cl><span class=n>TimeOnly</span> <span class=n>time</span> <span class=p>=</span> <span class=n>TimeOnly</span><span class=p>.</span><span class=n>FromDateTime</span><span class=p>(</span><span class=n>DateTime</span><span class=p>.</span><span class=n>Now</span><span class=p>);</span> <span class=c1>// Just the time.</span>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Date: {date}, Time: {time}&#34;</span><span class=p>);</span>
</span></span></code></pre></div><h4 id=c-11--net-7>C# 11 & .NET 7<a hidden class=anchor aria-hidden=true href=#c-11--net-7>#</a></h4><p><strong>The required keyword</strong> ensures certain properties are initialized during object creation, with checks enforced at compile time. This complements nullable reference types by preventing unintentionally uninitialized values.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Person</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>required</span> <span class=kt>string</span> <span class=n>Name</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>init</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// Must be set when creating the object.</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>person</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Person</span> <span class=p>{</span> <span class=n>Name</span> <span class=p>=</span> <span class=s>&#34;Alice&#34;</span> <span class=p>};</span> <span class=c1>// Valid.</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>invalidPerson</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>();</span> <span class=c1>// Compile-time error: Name is required.</span>
</span></span></code></pre></div><p><strong>Generated Regex</strong> through the RegexGenerator attribute generates highly efficient, precompiled regular expressions at compile time. This avoids runtime overhead and ensures better performance.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Text.RegularExpressions</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>[GeneratedRegex(&#34;^[a-zA-Z0-9]</span><span class=p>*</span><span class=s>$&#34;)]
</span></span></span><span class=line><span class=cl><span class=s>private static partial Regex AlphanumericRegex();
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>bool isValid = AlphanumericRegex().IsMatch(&#34;</span><span class=n>Sample123</span><span class=s>&#34;); // Uses precompiled regex.
</span></span></span></code></pre></div><p><strong>String Improvements</strong> introduced multiline triple quotes and multiline JSON, which allows strings to span multiple lines easily, preserving indentation and formatting.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>string</span> <span class=n>multiline</span> <span class=p>=</span> <span class=s>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s></span>    <span class=n>This</span> <span class=k>is</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=n>multi</span><span class=p>-</span><span class=n>line</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=n>with</span> <span class=s>&#34;quotes&#34;</span> <span class=n>and</span> <span class=n>special</span> <span class=n>characters</span><span class=p>!</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;&#34;&#34;;
</span></span></span><span class=line><span class=cl><span class=s></span>
</span></span><span class=line><span class=cl><span class=kt>string</span> <span class=n>json</span> <span class=p>=</span> <span class=s>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;name&#34;</span><span class=p>:</span> <span class=s>&#34;Alice&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;age&#34;</span><span class=p>:</span> <span class=m>30</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;&#34;&#34;;
</span></span></span></code></pre></div><p><strong>Enhanced generic support</strong> makes it easier to create APIs or response types with consistent, type-safe handling of different data structures.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>ApiResponse</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>T</span> <span class=n>Data</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=n>StatusCode</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>response</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ApiResponse</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=p>{</span> <span class=n>Data</span> <span class=p>=</span> <span class=s>&#34;Success&#34;</span><span class=p>,</span> <span class=n>StatusCode</span> <span class=p>=</span> <span class=m>200</span> <span class=p>};</span>
</span></span></code></pre></div><p><strong>File-scoped files</strong> allow you to declare types that are only accessible within the file they are defined in, improving encapsulation and reducing unintentional exposure.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>file</span> <span class=k>class</span> <span class=nc>InternalHelper</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=k>void</span> <span class=n>DoSomething</span><span class=p>()</span> <span class=p>=&gt;</span> <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;This is file-scoped.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=c-12--net-8>C# 12 & .NET 8<a hidden class=anchor aria-hidden=true href=#c-12--net-8>#</a></h4><p><strong>Primary Constructors</strong> made it so classes and structs could now declare constructor parameters directly within the type declaration, simplifying initialization and reducing boilerplate.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>Person</span><span class=p>(</span><span class=kt>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>int</span> <span class=n>age</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>string</span> <span class=n>Name</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=p>}</span> <span class=p>=</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>int</span> <span class=n>Age</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=p>}</span> <span class=p>=</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Collection Expressions</strong> provided a unified syntax for initializing collections, allowing concise creation of arrays, lists, and spans, with support for spread elements to include existing collections.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>numbers</span> <span class=p>=</span> <span class=p>[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>moreNumbers</span> <span class=p>=</span> <span class=p>[..</span><span class=n>numbers</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>5</span><span class=p>];</span>
</span></span></code></pre></div><p><strong>Alias Any Type</strong> as the using directive now supported it, including tuples and pointer types, enhancing code readability and disambiguation.</p><pre tabindex=0><code>using Point = (int X, int Y);
Point p = (10, 20);
</code></pre><p><strong>Layered Dependency Injection</strong> was improved. .NET 8 enhanced injection by allowing registration of multiple exception handlers that can be executed in a specified order, facilitating more granular error handling.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=n>builder</span><span class=p>.</span><span class=n>Services</span><span class=p>.</span><span class=n>AddExceptionHandler</span><span class=p>&lt;</span><span class=n>TimeoutExceptionHandler</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl><span class=n>builder</span><span class=p>.</span><span class=n>Services</span><span class=p>.</span><span class=n>AddExceptionHandler</span><span class=p>&lt;</span><span class=n>GlobalExceptionHandler</span><span class=p>&gt;();</span>
</span></span></code></pre></div><p><strong>Enhanced Exception Handling</strong> improved with the introduction of the IExceptionHandler interface, which enabled structured global exception handling without the need for custom middleware, allowing for more modular and maintainable error management.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>GlobalExceptionHandler</span> <span class=p>:</span> <span class=n>IExceptionHandler</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>async</span> <span class=n>ValueTask</span><span class=p>&lt;</span><span class=kt>bool</span><span class=p>&gt;</span> <span class=n>TryHandleAsync</span><span class=p>(</span><span class=n>HttpContext</span> <span class=n>httpContext</span><span class=p>,</span> <span class=n>Exception</span> <span class=n>exception</span><span class=p>,</span> <span class=n>CancellationToken</span> <span class=n>cancellationToken</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Handle exception</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=c-13--net-9>C# 13 & .NET 9<a hidden class=anchor aria-hidden=true href=#c-13--net-9>#</a></h4><p>At the time of the event, this version wasn&rsquo;t released yet. However, we did know what was coming and could talk about it.</p><p><strong>The params keyword</strong> has been enhanced to support various collection types beyond arrays, such as <code>Span&lt;T></code>, <code>ReadOnlySpan&lt;T></code>, and types implementing <code>IEnumerable&lt;T></code> with an <code>Add</code> method. This enhancement allows for more flexible and efficient method parameter definitions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>AddNumbers</span><span class=p>(</span><span class=k>params</span> <span class=n>Span</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=n>numbers</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=n>number</span> <span class=k>in</span> <span class=n>numbers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>number</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>AddNumbers</span><span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>);</span> <span class=c1>// Now valid with Span&lt;int&gt;</span>
</span></span></code></pre></div><p><strong>Ordered dictionaries</strong> were added. .NET 9 introduces <code>OrderedDictionary&lt;TKey, TValue></code>, a generic collection that maintains the order of elements as they are added, combining the features of a list and a dictionary.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>var</span> <span class=n>orderedDict</span> <span class=p>=</span> <span class=k>new</span> <span class=n>OrderedDictionary</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>,</span> <span class=kt>int</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=na>    [&#34;apple&#34;]</span> <span class=p>=</span> <span class=m>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=na>    [&#34;banana&#34;]</span> <span class=p>=</span> <span class=m>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=na>    [&#34;cherry&#34;]</span> <span class=p>=</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=n>item</span> <span class=k>in</span> <span class=n>orderedDict</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;{item.Key}: {item.Value}&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>The read-only set</strong> is a new collection type <code>ReadOnlySet&lt;T></code> that provides a read-only wrapper around a set, allowing for the exposure of set data without permitting modifications.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>var</span> <span class=n>modifiableSet</span> <span class=p>=</span> <span class=k>new</span> <span class=n>HashSet</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>readOnlySet</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ReadOnlySet</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;(</span><span class=n>modifiableSet</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>readOnlySet</span><span class=p>.</span><span class=n>Contains</span><span class=p>(</span><span class=m>2</span><span class=p>));</span> <span class=c1>// True</span>
</span></span><span class=line><span class=cl><span class=c1>// readOnlySet.Add(4); // Compile-time error</span>
</span></span></code></pre></div><p><strong>LINQ Enhancements</strong> were made. C# 13 introduces improvements to Language Integrated Query (LINQ), including support for indexing and new aggregation methods, enhancing the expressiveness and performance of LINQ queries.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kt>var</span> <span class=n>numbers</span> <span class=p>=</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>5</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>thirdElement</span> <span class=p>=</span> <span class=n>numbers</span><span class=p>.</span><span class=n>ElementAt</span><span class=p>(^</span><span class=m>3</span><span class=p>);</span> <span class=c1>// Index from end, retrieves 3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>var</span> <span class=n>sum</span> <span class=p>=</span> <span class=n>numbers</span><span class=p>.</span><span class=n>AggregateBy</span><span class=p>((</span><span class=n>total</span><span class=p>,</span> <span class=n>next</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>total</span> <span class=p>+</span> <span class=n>next</span><span class=p>);</span> <span class=c1>// Hypothetical new method</span>
</span></span></code></pre></div><p><strong>The partial keyword</strong> has been extended to properties and indexers, allowing their declarations to be split across multiple partial class definitions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=c1>// In one part of the partial class</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>partial</span> <span class=k>class</span> <span class=nc>SampleClass</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>partial</span> <span class=kt>string</span> <span class=n>Name</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// In another part of the partial class</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>partial</span> <span class=k>class</span> <span class=nc>SampleClass</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>partial</span> <span class=kt>string</span> <span class=n>Name</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span> <span class=p>=</span> <span class=s>&#34;Default&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=predictions>Predictions<a hidden class=anchor aria-hidden=true href=#predictions>#</a></h2><p>According to Colin Bundervoet, the future of .NET lies in leveraging <strong>extensions and roles</strong> to drive flexibility and maintainability in application development.</p><p>He predicts that extensions will continue to evolve as a way to add functionality to existing types without altering their original design, allowing for more modular and reusable code.</p><p>Bundervoet also sees roles as a game-changer, enabling type aliases with constraints and context-specific behaviors that enforce compile-time safety while improving code readability.</p><p>He believes these features will align .NET with modern design paradigms like domain-driven design, making it easier to build adaptable, scalable applications. In Bundervoet&rsquo;s view, this focus on extensions and roles cements .NET&rsquo;s position as a versatile and forward-thinking platform.</p><h2 id=final-remarks>Final remarks<a hidden class=anchor aria-hidden=true href=#final-remarks>#</a></h2><p>In the end, we ended up networking a bit amongst ourselves and with the people at Starfisk. We discussed Bruges, our studies and the Colin Bundervoet&rsquo;s talk extensively. There were free drinks and snacks as well, which kept us there for about half an hour after.</p><p><img alt="group picture" loading=lazy src=/images/starfisk-group.jpg></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wolfschevelenbos.netlify.app/tags/tech/>Tech</a></li><li><a href=https://wolfschevelenbos.netlify.app/tags/passive-event/>Passive Event</a></li></ul><nav class=paginav><a class=prev href=https://wolfschevelenbos.netlify.app/posts/ai-reality-hidden-behind-the-hype/><span class=title>« Prev</span><br><span>AI - the Reality Hidden Behind the Hype</span>
</a><a class=next href=https://wolfschevelenbos.netlify.app/posts/hello-world/><span class=title>Next »</span><br><span>Hello World</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://wolfschevelenbos.netlify.app/>Wolf's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>